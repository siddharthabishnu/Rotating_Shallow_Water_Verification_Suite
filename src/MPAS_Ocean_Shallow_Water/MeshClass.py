"""
Name: MeshClass.py
Author: Sid Bishnu
Details: This script defines the MPAS-Ocean shallow water mesh class. It also contains routines for interpolating 
(a) the state variables from the vertices and the edges to the cell centers of a MPAS-Ocean Mesh, and 
(b) the state variables from the cell centers of a structured MPAS-Ocean Mesh to the cell centers of a rectilinear mesh 
    generated by shifting the cell centers of every other row of the original structured MPAS-Ocean Mesh by half a cell 
    width, and 
(c) the state variables from the cell centers of a structured MPAS-Ocean Mesh to the cell centers of a coarser 
    rectilinear mesh occupying the same physical space as the one mentioned in (b) but containing fewer cells in each 
    direction.
"""


import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from netCDF4 import Dataset
import os
from IPython.utils import io
with io.capture_output() as captured:
    import CommonRoutines as CR
    import CommonRoutines_CellAndEdgeAveragedQuantities as CRCEAQ
    import FixAngleEdgeRoutines
    

class Mesh:
    
    def __init__(myMesh,myNameList,PrintBasicGeometry,MeshDirectory,BaseMeshFileName,MeshFileName,FixAngleEdge,
                 PrintOutput,UseAveragedQuantities,SpecifyBoundaryCondition=False,BoundaryCondition='Periodic',
                 ReadDomainExtentsfromMeshFile=False,DebugVersion=False):
        myMesh.MeshType = 'uniform'
        if not(SpecifyBoundaryCondition):
            BoundaryCondition = myNameList.BoundaryCondition
        cwd = os.getcwd()
        path = cwd + '/' + MeshDirectory + '/'
        if not os.path.exists(path):
            os.mkdir(path) # os.makedir(path)
        os.chdir(path)
        # base mesh file
        BaseMeshFile = Dataset(BaseMeshFileName, "r", format='NETCDF4_CLASSIC')
        # mesh file
        MeshFile = Dataset(MeshFileName, "r", format='NETCDF4_CLASSIC')
        # Get the values of the dimensions.
        myMesh.nCells = len(MeshFile.dimensions['nCells'])
        myMesh.nEdges = len(MeshFile.dimensions['nEdges'])
        myMesh.nVertices = len(MeshFile.dimensions['nVertices'])
        myMesh.maxEdges = len(MeshFile.dimensions['maxEdges'])
        myMesh.maxEdges2 = len(MeshFile.dimensions['maxEdges2'])
        myMesh.vertexDegree = len(MeshFile.dimensions['vertexDegree'])
        myMesh.nBoundaryEdges = 0
        myMesh.nBoundaryVertices = 0
        myMesh.nBoundaryCells = 0
        myMesh.nInternalEdges = 0
        myMesh.nInternalVertices = 0
        myMesh.nInternalCells = 0
        nCells = myMesh.nCells
        nEdges = myMesh.nEdges
        nVertices = myMesh.nVertices
        maxEdges = myMesh.maxEdges
        if PrintBasicGeometry:
            print('The number of cells is %d.' %nCells)
            print('The number of edges is %d.' %nEdges)
            print('The number of vertices is %d.' %nVertices)
        # Get the values of the variables.
        myMesh.xCell = BaseMeshFile.variables['xCell'][:]        
        myMesh.yCell = BaseMeshFile.variables['yCell'][:]      
        myMesh.xVertex = BaseMeshFile.variables['xVertex'][:]
        myMesh.yVertex = BaseMeshFile.variables['yVertex'][:]
        myMesh.nEdgesOnCell = BaseMeshFile.variables['nEdgesOnCell'][:]
        # Choose myMeshFileName to be either BaseMeshFileName or MeshFileName.
        myMeshFileName = MeshFileName
        # Choose myMeshFile to be either BaseMeshFile or MeshFile.
        myMeshFile = MeshFile
        myMesh.areaCell = myMeshFile.variables['areaCell'][:]
        myMesh.dcEdge = myMeshFile.variables['dcEdge'][:]
        myMesh.dvEdge = myMeshFile.variables['dvEdge'][:]
        myMesh.areaTriangle = myMeshFile.variables['areaTriangle'][:]
        # Even though the following arrays are contained within the base mesh (or culled mesh) file, the local and 
        # global ordering of the edges and hence the sequence of elements of these arrays are modified by the 
        # mpas_mesh_converter.cpp file which generates the mesh file using from base mesh (or culled mesh) file. The 
        # implementation of non-periodic boundary conditions also modifies some of these arrays within the culled mesh 
        # file. That is why we are reading all of these arrays from the mesh file.
        myMesh.xEdge = myMeshFile.variables['xEdge'][:]
        myMesh.yEdge = myMeshFile.variables['yEdge'][:]
        myMesh.edgesOnCell = myMeshFile.variables['edgesOnCell'][:]
        myMesh.verticesOnCell = myMeshFile.variables['verticesOnCell'][:]
        myMesh.edgesOnEdge = myMeshFile.variables['edgesOnEdge'][:]
        myMesh.cellsOnEdge = myMeshFile.variables['cellsOnEdge'][:]
        myMesh.verticesOnEdge = myMeshFile.variables['verticesOnEdge'][:] 
        myMesh.nEdgesOnEdge = myMeshFile.variables['nEdgesOnEdge'][:] 
        myMesh.cellsOnVertex = myMeshFile.variables['cellsOnVertex'][:]
        myMesh.edgesOnVertex = myMeshFile.variables['edgesOnVertex'][:]
        myMesh.angleEdge = myMeshFile.variables['angleEdge'][:]
        myMesh.weightsOnEdge = myMeshFile.variables['weightsOnEdge'][:]
        myMesh.kiteAreasOnVertex = myMeshFile.variables['kiteAreasOnVertex'][:]
        myMesh.nCellsX = myNameList.nCellsX
        myMesh.nCellsY = myNameList.nCellsY
        if ReadDomainExtentsfromMeshFile:
            dx = myMesh.dcEdge[0]
            dy = np.sqrt(3.0)/2.0*dx
            lX = float(myMesh.nCellsX)*dx
            lY = np.sqrt(3.0)/2.0*lX
        else:
            lX = myNameList.lX
            lY = myNameList.lY
            dx = myNameList.dx
            dy = myNameList.dy
        myMesh.lX = lX
        myMesh.lY = lY
        myMesh.dx = dx
        myMesh.dy = dy
        myMesh.dc = dx
        myMesh.dv = dx/np.sqrt(3.0)
        HexagonLength = myMesh.dv
        HexagonArea = 6.0*np.sqrt(3.0)/4.0*HexagonLength**2.0
        myMesh.areaCell[:] = HexagonArea
        myMesh.dcEdge[:] = dx
        myMesh.dvEdge[:] = HexagonLength
        # For a mesh with non-periodic zonal boundaries, adjust the zonal coordinates of the cell centers, vertices and
        # edges.
        if BoundaryCondition == 'NonPeriodic_x' or BoundaryCondition == 'NonPeriodic_xy':
            myMesh.xCell[:] -= dx
            myMesh.xVertex[:] -= dx
            myMesh.xEdge[:] -= dx
        if BoundaryCondition == 'NonPeriodic_y' or BoundaryCondition == 'NonPeriodic_xy':
            myMesh.yCell[:] -= dy
            myMesh.yVertex[:] -= dy
            myMesh.yEdge[:] -= dy
        if BoundaryCondition == 'Periodic' or BoundaryCondition == 'NonPeriodic_y':
            for iEdge in range(0,myMesh.nEdges):
                if myMesh.xEdge[iEdge] > myMesh.lX:
                    myMesh.xEdge[iEdge] -= myMesh.lX 
        if BoundaryCondition == 'NonPeriodic_x':
            for iEdge in range(0,myMesh.nEdges):
                if myMesh.yEdge[iEdge] > myMesh.lY:
                    myMesh.yEdge[iEdge] -= myMesh.lY
        if myNameList.ProblemType_EquatorialWave:
            myMesh.yCell[:] -= 0.5*lY
            myMesh.yVertex[:] -= 0.5*lY
            myMesh.yEdge[:] -= 0.5*lY
        # Initialize the following arrays not contained within the base mesh file or the mesh file.
        myMesh.fEdge = np.zeros(nEdges)
        myMesh.fVertex = np.zeros(nVertices)
        myMesh.bottomDepth = np.zeros(nCells)
        myMesh.bottomDepthEdge = np.zeros(nEdges)
        myMesh.boundaryCell = np.zeros(nCells)
        myMesh.boundaryEdge = np.zeros(nEdges)
        myMesh.boundaryVertex = np.zeros(nVertices)
        myMesh.nBoundaryEdgesOnCell = np.zeros(nCells,dtype=int)
        myMesh.nBoundaryVerticesOnCell = np.zeros(nCells,dtype=int)
        myMesh.edgeSignOnCell = np.zeros((nCells,maxEdges))
        myMesh.edgeSignOnVertex = np.zeros((nVertices,maxEdges))
        myMesh.kiteIndexOnCell = np.zeros((nCells,maxEdges),dtype=int)
        myMesh.kiteAreasOnCell = np.zeros((nCells,maxEdges))
        myMesh.triangleAreasOnCell = np.zeros((nCells,maxEdges))
        myMesh.localIndexOfEdgeOnCell = -np.ones((nEdges,2),dtype=int)
        myMesh.diamondAreaOnEdge = np.zeros(nEdges)
        myMesh.areaHexagonAtVertex = np.zeros(nVertices)
        os.chdir(cwd)
        if FixAngleEdge:
            if PrintOutput:
                print(' ')
            myMesh.angleEdge[:] = (
            FixAngleEdgeRoutines.FixAngleEdge(MeshDirectory,myMeshFileName,DetermineYCellAlongLatitude=True,
                                              PrintOutput=PrintOutput,PrintRelevantMeshData=False))
        myMesh.UseAveragedQuantities = UseAveragedQuantities
        if UseAveragedQuantities:
            myMesh.myQuadratureOnHexagon = CRCEAQ.QuadratureOnHexagon()
            myMesh.HexagonLength = HexagonLength
            nX = 2
            myMesh.myQuadratureOnEdge = CRCEAQ.LegendreGaussQuadrature1D(nX)
        else:
            myMesh.myQuadratureOnHexagon = []
            myMesh.HexagonLength = 1.0
            myMesh.myQuadratureOnEdge = []
        myMesh.SpecifyBoundaryCellsEdgesAndVertices(DebugVersion=DebugVersion,OutputDirectory=MeshDirectory,
                                                    OutputFileName='BoundaryCellsEdgesAndVertices')
        myMesh.SetUpSignAndIndexFields(DebugVersion=DebugVersion,OutputDirectory=MeshDirectory,
                                       OutputFileName='SignAndIndexFields')
        myMesh.ComputeLocalIndexOfEdgesOnCells()
        myMesh.ComputeKiteTriangleAndDiamondAreasOnCellsAndEdges(
        DebugVersion=DebugVersion,OutputDirectory=MeshDirectory,
        OutputFileName='KiteTriangleAndDiamondAreasOnCellsAndEdges')
        myMesh.ComputeHexagonAreaAtVertices(DebugVersion=DebugVersion,OutputDirectory=MeshDirectory,
                                            OutputFileName='HexagonAreaAtVertices')
  
    def PlotMesh(myMesh,OutputDirectory,linewidth,linestyle,color,labels,labelfontsizes,labelpads,tickfontsizes,title,
                 titlefontsize,SaveAsPDF,FileName,Show,fig_size=[9.5,9.5],UseDefaultMethodToSpecifyTickFontSize=True,
                 PlotCellCenters=False,CellCenterMarkerType="s",CellCenterMarkerSize=7.5,PlotEdgeCenters=False,
                 EdgeCenterMarkerType="s",EdgeCenterMarkerSize=7.5,PlotVertices=False,VertexMarkerType="o",
                 VertexMarkerSize=7.5,PlotUnitVectorsAlongAngleEdges=False,VectorScale=1.0):
        cwd = os.getcwd()
        path = cwd + '/' + OutputDirectory + '/'
        if not os.path.exists(path):
            os.mkdir(path) # os.makedir(path)
        os.chdir(path)    
        fig = plt.figure(figsize=(fig_size[0],fig_size[1])) # Create a figure object
        ax = fig.add_subplot(111) # Create an axes object in the figure
        for iEdge in range(0,myMesh.nEdges):
            dvEdge = myMesh.dvEdge[iEdge]
            vertexID1 = myMesh.verticesOnEdge[iEdge,0]
            vertexID2 = myMesh.verticesOnEdge[iEdge,1]
            iVertex1 = vertexID1 - 1
            iVertex2 = vertexID2 - 1
            x1 = myMesh.xVertex[iVertex1]
            x2 = myMesh.xVertex[iVertex2]
            y1 = myMesh.yVertex[iVertex1]
            y2 = myMesh.yVertex[iVertex2]
            edgeLength = np.sqrt((x2 - x1)**2.0 + (y2 - y1)**2.0)
            dvEdgeTolerancePercentage = 1.0
            if edgeLength <= dvEdge*(100.0 + dvEdgeTolerancePercentage)/100.0:
                plt.plot([x1,x2],[y1,y2],linewidth=linewidth,linestyle=linestyle,color=color)
        if PlotCellCenters:
            for iCell in range(0,myMesh.nCells):
                plt.plot([myMesh.xCell[iCell]],[myMesh.yCell[iCell]],color='k',marker=CellCenterMarkerType,
                         markersize=CellCenterMarkerSize)
        if PlotEdgeCenters:
            for iEdge in range(0,myMesh.nEdges):
                plt.plot([myMesh.xEdge[iEdge]],[myMesh.yEdge[iEdge]],color='lime',marker=EdgeCenterMarkerType,
                         markersize=EdgeCenterMarkerSize)
        if PlotVertices:
            for iVertex in range(0,myMesh.nVertices):
                plt.plot([myMesh.xVertex[iVertex]],[myMesh.yVertex[iVertex]],color='r',marker=VertexMarkerType,
                         markersize=VertexMarkerSize)
        if PlotUnitVectorsAlongAngleEdges:
            for iEdge in range(0,myMesh.nEdges):
                x = myMesh.xEdge[iEdge]
                y = myMesh.yEdge[iEdge]
                u = np.cos(myMesh.angleEdge[iEdge])*myMesh.dcEdge[iEdge]
                v = np.sin(myMesh.angleEdge[iEdge])*myMesh.dcEdge[iEdge]
                plt.quiver(x,y,u,v,color='b',scale=VectorScale,scale_units='xy')
        plt.xlabel(labels[0],fontsize=labelfontsizes[0],labelpad=labelpads[0])
        plt.ylabel(labels[1],fontsize=labelfontsizes[1],labelpad=labelpads[1])
        if UseDefaultMethodToSpecifyTickFontSize:
            plt.xticks(fontsize=tickfontsizes[0])
            plt.yticks(fontsize=tickfontsizes[1])
        else:
            ax.tick_params(axis='x',labelsize=tickfontsizes[0])
            ax.tick_params(axis='y',labelsize=tickfontsizes[1])
        plt.gca().get_xaxis().set_major_formatter(FuncFormatter(lambda x, p: format(int(x/1000.0), '')))
        plt.gca().get_yaxis().set_major_formatter(FuncFormatter(lambda y, p: format(int(y/1000.0), '')))
        ax.set_title(title,fontsize=titlefontsize,fontweight='bold',y=1.035)
        if SaveAsPDF:
            plt.savefig(FileName+'.pdf',format='pdf',bbox_inches='tight')
        if Show:
            plt.show()
        plt.close()
        os.chdir(cwd)
        
    def SpecifyBoundaryCellsEdgesAndVertices(myMesh,DebugVersion=False,OutputDirectory='',OutputFileName=''):
        for iEdge in range(0,myMesh.nEdges):
            CellID1 = myMesh.cellsOnEdge[iEdge,0]
            iCell1 = CellID1 - 1
            CellID2 = myMesh.cellsOnEdge[iEdge,1]
            iCell2 = CellID2 - 1 
            if CellID1 == 0 or CellID2 == 0: # i.e. if the edge is along a non-periodic boundary of the domain
                myMesh.boundaryEdge[iEdge] = 1.0
        # Find cells and vertices that have an edge on the boundary.
        for iEdge in range(0,myMesh.nEdges):
            CellID1 = myMesh.cellsOnEdge[iEdge,0]
            iCell1 = CellID1 - 1
            CellID2 = myMesh.cellsOnEdge[iEdge,1]
            iCell2 = CellID2 - 1   
            iVertexID1 = myMesh.verticesOnEdge[iEdge,0]
            iVertex1 = iVertexID1 - 1
            iVertexID2 = myMesh.verticesOnEdge[iEdge,1]
            iVertex2 = iVertexID2 - 1                  
            if myMesh.boundaryEdge[iEdge] == 1.0:
                if CellID1 != 0:
                    myMesh.boundaryCell[iCell1] = 1.0
                if CellID2 != 0:    
                    myMesh.boundaryCell[iCell2] = 1.0
                myMesh.boundaryVertex[iVertex1] = 1.0
                myMesh.boundaryVertex[iVertex2] = 1.0
        for iEdge in range(0,myMesh.nEdges):
            if myMesh.boundaryEdge[iEdge] == 1.0:
                myMesh.nBoundaryEdges += 1
        myMesh.nInternalEdges = myMesh.nEdges - myMesh.nBoundaryEdges
        for iVertex in range(0,myMesh.nVertices):
            if myMesh.boundaryVertex[iVertex] == 1.0:
                myMesh.nBoundaryVertices += 1       
        myMesh.nInternalVertices = myMesh.nVertices - myMesh.nBoundaryVertices     
        for iCell in range(0,myMesh.nCells):
            if myMesh.boundaryCell[iCell] == 1.0:
                myMesh.nBoundaryCells += 1
            for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                EdgeID = myMesh.edgesOnCell[iCell,iEdgeOnCell]
                iEdge = EdgeID - 1
                if myMesh.boundaryEdge[iEdge] == 1.0:
                    myMesh.nBoundaryEdgesOnCell[iCell] += 1
            for iVertexOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                iVertexID = myMesh.verticesOnCell[iCell,iVertexOnCell]
                iVertex = iVertexID - 1
                if myMesh.boundaryVertex[iVertex] == 1.0:
                    myMesh.nBoundaryVerticesOnCell[iCell] += 1      
        myMesh.nInternalCells = myMesh.nCells - myMesh.nBoundaryCells 
        if DebugVersion:
            cwd = os.getcwd()
            path = cwd + '/' + OutputDirectory + '/'
            if not os.path.exists(path):
                os.mkdir(path) # os.makedir(path)
            os.chdir(path)
            OutputFileName += '.txt'
            OutputFile = open(OutputFileName,'w')
            OutputFile.write('boundaryEdge is:\n\n')
            OutputFile.write(str(myMesh.boundaryEdge[:]))
            OutputFile.write('\n\nThe number of non-periodic boundary edges is %d.' %(myMesh.nBoundaryEdges))
            OutputFile.write('\n\nboundaryVertex is:\n\n')
            OutputFile.write(str(myMesh.boundaryVertex[:]))
            OutputFile.write('\n\nThe number of non-periodic boundary vertices is %d.' %(myMesh.nBoundaryVertices))
            OutputFile.write('\n\nboundaryCell is:\n\n')
            OutputFile.write(str(myMesh.boundaryCell[:]))
            OutputFile.write('\n\nThe number of non-periodic boundary cells is %d.' %(myMesh.nBoundaryCells))   
            OutputFile.close()
            os.chdir(cwd)   
            
    def SetUpSignAndIndexFields(myMesh,DebugVersion=False,OutputDirectory='',OutputFileName=''):
        if DebugVersion:
            cwd = os.getcwd()
            path = cwd + '/' + OutputDirectory + '/'
            if not os.path.exists(path):
                os.mkdir(path) # os.makedir(path)
            os.chdir(path)
            OutputFileName += '.txt'
            OutputFile = open(OutputFileName,'w')
            OutputFile.write('CellID iEdgeOnCell+1 EdgeID boundaryEdge[iEdge] cellsOnEdge[iEdge,0] cellsOnEdge[iEdge,1]'
                             + ' edgeSignOnCell[iCell,iEdgeOnCell] angleEdge[iEdge]\n\n')
        for iCell in range(0,myMesh.nCells):
            CellID = iCell + 1
            for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                EdgeID = myMesh.edgesOnCell[iCell,iEdgeOnCell]
                iEdge = EdgeID - 1
                boundaryEdge = myMesh.boundaryEdge[iEdge]
                iVertexID = myMesh.verticesOnCell[iCell,iEdgeOnCell]
                iVertex = iVertexID - 1
                # Vector points from cell 1 to cell 2.
                if myMesh.cellsOnEdge[iEdge,0] == CellID:
                    myMesh.edgeSignOnCell[iCell,iEdgeOnCell] = -1.0
                else:
                    myMesh.edgeSignOnCell[iCell,iEdgeOnCell] = 1.0
                if DebugVersion:
                    OutputFile.write('%6d %1d %9d %d %6d %6d %+d %+.2f\n' 
                                     %(CellID,iEdgeOnCell+1,EdgeID,boundaryEdge,myMesh.cellsOnEdge[iEdge,0],
                                       myMesh.cellsOnEdge[iEdge,1],myMesh.edgeSignOnCell[iCell,iEdgeOnCell],
                                       myMesh.angleEdge[iEdge]))
                for iVertexDegree in range(0,myMesh.vertexDegree):
                    if myMesh.cellsOnVertex[iVertex,iVertexDegree] == CellID:
                        myMesh.kiteIndexOnCell[iCell,iEdgeOnCell] = iVertexDegree + 1    
        if DebugVersion:
            OutputFile.write('\n')
            for iCell in range(0,myMesh.nCells):
                for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                    OutputFile.write('On vertex %d of cell %2d, kiteIndexOnCell is %d.\n' 
                                     %(iEdgeOnCell,iCell,myMesh.kiteIndexOnCell[iCell,iEdgeOnCell]))
        for iVertex in range(0,myMesh.nVertices):
            iVertexID = iVertex + 1
            for iVertexDegree in range(0,myMesh.vertexDegree):
                EdgeID = myMesh.edgesOnVertex[iVertex,iVertexDegree]
                iEdge = EdgeID - 1
                # Vector points from vertex 1 to vertex 2.
                if myMesh.verticesOnEdge[iEdge,0] == iVertexID:
                    myMesh.edgeSignOnVertex[iVertex,iVertexDegree] = -1.0
                else:
                    myMesh.edgeSignOnVertex[iVertex,iVertexDegree] = 1.0
        if DebugVersion:
            OutputFile.close()
            os.chdir(cwd)
            
    def ComputeLocalIndexOfEdgesOnCells(myMesh):
        for iEdge in range(0,myMesh.nEdges):
            EdgeID = iEdge + 1
            CellID1 = myMesh.cellsOnEdge[iEdge,0]
            CellID2 = myMesh.cellsOnEdge[iEdge,1]
            iCell1 = CellID1 - 1
            iCell2 = CellID2 - 1
            if CellID1 != 0:
                myMesh.localIndexOfEdgeOnCell[iEdge,0] = np.where(myMesh.edgesOnCell[iCell1,:] == EdgeID)[0]
            if CellID2 != 0:
                myMesh.localIndexOfEdgeOnCell[iEdge,1] = np.where(myMesh.edgesOnCell[iCell2,:] == EdgeID)[0]

    def ComputeKiteTriangleAndDiamondAreasOnCellsAndEdges(myMesh,DebugVersion=False,OutputDirectory='',
                                                          OutputFileName=''):
        for iCell in range(0,myMesh.nCells):
            for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                VertexID = myMesh.verticesOnCell[iCell,iEdgeOnCell]
                iVertex = VertexID - 1
                kiteIndexOnCell = myMesh.kiteIndexOnCell[iCell,iEdgeOnCell]
                iKiteIndexOnCell = kiteIndexOnCell - 1
                myMesh.kiteAreasOnCell[iCell,iEdgeOnCell] = myMesh.kiteAreasOnVertex[iVertex,iKiteIndexOnCell]
        for iCell in range(0,myMesh.nCells):
            for iVertexOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                iVertexOnCell1 = iVertexOnCell
                if iVertexOnCell1 == myMesh.nEdgesOnCell[iCell] - 1:
                    iVertexOnCell2 = 0
                else:
                    iVertexOnCell2 = iVertexOnCell1 + 1
                vertexID1 = myMesh.verticesOnCell[iCell,iVertexOnCell1]
                iVertex1 = vertexID1 - 1
                vertexID2 = myMesh.verticesOnCell[iCell,iVertexOnCell2]
                iVertex2 = vertexID2 - 1
                kiteAreaOnVertex1 = myMesh.kiteAreasOnCell[iCell,iVertexOnCell1]
                kiteAreaOnVertex2 = myMesh.kiteAreasOnCell[iCell,iVertexOnCell2]
                edgeIDs = np.intersect1d(myMesh.edgesOnVertex[iVertex1,:],myMesh.edgesOnVertex[iVertex2,:])
                for i in range(0,len(edgeIDs)):
                    if edgeIDs[i] != 0:
                        edgeID = edgeIDs[i]
                iEdgeOnCell = np.where(myMesh.edgesOnCell[iCell,:] == edgeID)[0]
                myMesh.triangleAreasOnCell[iCell,iEdgeOnCell] = 0.5*(kiteAreaOnVertex1 + kiteAreaOnVertex2)
        for iEdge in range(0,myMesh.nEdges):
            CellID1 = myMesh.cellsOnEdge[iEdge,0]
            CellID2 = myMesh.cellsOnEdge[iEdge,1]
            iCell1 = CellID1 - 1
            iCell2 = CellID2 - 1
            localIndexOfEdgeOnCell1 = myMesh.localIndexOfEdgeOnCell[iEdge,0]
            localIndexOfEdgeOnCell2 = myMesh.localIndexOfEdgeOnCell[iEdge,1]
            triangleAreaOnEdge_Cell1 = myMesh.triangleAreasOnCell[iCell1,localIndexOfEdgeOnCell1]
            triangleAreaOnEdge_Cell2 = myMesh.triangleAreasOnCell[iCell2,localIndexOfEdgeOnCell2]
            if myMesh.boundaryEdge[iEdge] == 1.0:
                if CellID1 == 0:
                    myMesh.diamondAreaOnEdge[iEdge] = 2.0*triangleAreaOnEdge_Cell2
                elif CellID2 == 0:
                    myMesh.diamondAreaOnEdge[iEdge] = 2.0*triangleAreaOnEdge_Cell1
            else:
                myMesh.diamondAreaOnEdge[iEdge] = triangleAreaOnEdge_Cell1 + triangleAreaOnEdge_Cell2
        if DebugVersion:
            cwd = os.getcwd()
            path = cwd + '/' + OutputDirectory + '/'
            if not os.path.exists(path):
                os.mkdir(path) # os.makedir(path)
            os.chdir(path)
            OutputFileName += '.txt'
            OutputFile = open(OutputFileName,'w')
            OutputFile.write('\nCellID iEdgeOnCell VertexID kiteArea EdgeID triangleArea\n\n')
            for iCell in range(0,myMesh.nCells):
                CellID = iCell + 1
                for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                    VertexID = myMesh.verticesOnCell[iCell,iEdgeOnCell]
                    EdgeID = VertexID
                    kiteArea = myMesh.kiteAreasOnCell[iCell,iEdgeOnCell]
                    triangleArea = myMesh.triangleAreasOnCell[iCell,iEdgeOnCell]
                    OutputFile.write('%6d %1d %9d %.3f %9d %.3f\n' %(CellID, iEdgeOnCell, VertexID, kiteArea, EdgeID, 
                                                                     triangleArea))
            OutputFile.write('\nEdgeID CellID1 CellID2 localIndexOfEdgeOnCell1 localIndexOfEdgeOnCell2 '
                             + 'triangleAreaOnEdge_Cell1 triangleAreaOnEdge_Cell2 diamondAreaOnEdge\n\n')
            for iEdge in range(0,myMesh.nEdges):
                CellID1 = myMesh.cellsOnEdge[iEdge,0]
                CellID2 = myMesh.cellsOnEdge[iEdge,1]
                iCell1 = CellID1 - 1
                iCell2 = CellID2 - 1
                localIndexOfEdgeOnCell1 = myMesh.localIndexOfEdgeOnCell[iEdge,0]
                localIndexOfEdgeOnCell2 = myMesh.localIndexOfEdgeOnCell[iEdge,1]
                triangleAreaOnEdge_Cell1 = myMesh.triangleAreasOnCell[iCell1,localIndexOfEdgeOnCell1]
                triangleAreaOnEdge_Cell2 = myMesh.triangleAreasOnCell[iCell2,localIndexOfEdgeOnCell2]
                diamondAreaOnEdge = myMesh.diamondAreaOnEdge[iEdge]
                OutputFile.write('%9d %6d %6d %+1d %+1d %.3f %.3f %.3f\n' 
                                 %(iEdge+1, CellID1, CellID2, localIndexOfEdgeOnCell1, localIndexOfEdgeOnCell2, 
                                   triangleAreaOnEdge_Cell1, triangleAreaOnEdge_Cell2, diamondAreaOnEdge))
            OutputFile.close()
            os.chdir(cwd)
            
    def ComputeHexagonAreaAtVertices(myMesh,DebugVersion=False,OutputDirectory='',OutputFileName=''):
        if DebugVersion:
            cwd = os.getcwd()
            path = cwd + '/' + OutputDirectory + '/'
            if not os.path.exists(path):
                os.mkdir(path) # os.makedir(path)
            os.chdir(path)
            OutputFileName += '.txt'
            OutputFile = open(OutputFileName,'w')
            OutputFile.write('\nVertexID areaHexagonAtVertex\n\n')
        for iVertex in range(0,myMesh.nVertices):
            VertexID = iVertex + 1
            for iVertexDegree in range(0,myMesh.vertexDegree):
                EdgeID = myMesh.edgesOnVertex[iVertex,iVertexDegree]
                iEdge = EdgeID - 1 
                myMesh.areaHexagonAtVertex[iVertex] += myMesh.diamondAreaOnEdge[iEdge]
            if DebugVersion:
                OutputFile.write('%9d %.3f\n' %(VertexID, myMesh.areaHexagonAtVertex[iVertex]))
        if DebugVersion:
            OutputFile.close()
            os.chdir(cwd)

    def GenerateRectilinearMPASOceanMesh(myMesh,BoundaryCondition):
        nCellsX = myMesh.nCellsX
        xCell = np.zeros(myMesh.nCells)
        xCell[:] = myMesh.xCell[:]
        yCell = np.zeros(myMesh.nCells)
        yCell[:] = myMesh.yCell[:]
        # If you want to duplicate an existing array in Python, initialize the duplicate array first and then copy its
        # contents from the existing one, instead of simply assigning the existing array to the duplicate one. The 
        # latter action is equivalent to specifying the duplicate array to be a pointer to the existing array. For 
        # example, if you want to copy the existing array myMesh.xCell to a duplicate array xCell, you should type
        #     xCell = np.zeros(myMesh.nCells)
        #     xCell[:] = myMesh.xCell[:]
        # instead of
        #     xCell = myMesh.xCell
        for iCell in range(0,myMesh.nCells):
            iCellY = int(float(iCell)/float(nCellsX))
            if BoundaryCondition == 'Periodic' or BoundaryCondition == 'NonPeriodic_x':
                if np.mod(float(iCellY),2.0) == 1.0:
                    xCell[iCell] = myMesh.xCell[iCell] - 0.5*myMesh.dx
            elif BoundaryCondition == 'NonPeriodic_y' or BoundaryCondition == 'NonPeriodic_xy':
                if np.mod(float(iCellY),2.0) == 0.0:
                    xCell[iCell] = myMesh.xCell[iCell] - 0.5*myMesh.dx            
        return xCell, yCell
    
    def InterpolateSolutionFromMPASOceanMeshToRectilinearMPASOceanMesh(myMesh,BoundaryCondition,Solution):
        nCellsX = myMesh.nCellsX
        InterpolatedSolution = np.zeros(myMesh.nCells)
        if BoundaryCondition == 'Periodic' or BoundaryCondition == 'NonPeriodic_x':
            shifted_row_index_mod_2 = 1.0
        elif BoundaryCondition == 'NonPeriodic_y' or BoundaryCondition == 'NonPeriodic_xy':
            shifted_row_index_mod_2 = 0.0
        for iCell in range(0,myMesh.nCells):
            iCellY = int(float(iCell)/float(nCellsX))
            if np.mod(float(iCellY),2.0) == shifted_row_index_mod_2:
                if np.mod(float(iCell),float(nCellsX)) == 0.0:
                    if BoundaryCondition == 'Periodic' or BoundaryCondition == 'NonPeriodic_y':
                        iCell1 = iCell - 1 + nCellsX
                        iCell2 = iCell                    
                        f1 = Solution[iCell1]
                        f2 = Solution[iCell2]                         
                        InterpolatedSolution[iCell] = 0.5*(f1 + f2)                    
                    elif BoundaryCondition == 'NonPeriodic_x':
                        iCell1 = iCell - nCellsX
                        iCell2 = int(np.mod(float(iCell+nCellsX),float(myMesh.nCells)))
                        f1 = Solution[iCell1]
                        f2 = Solution[iCell2] 
                        InterpolatedSolution[iCell] = 0.5*(f1 + f2)                     
                    elif BoundaryCondition == 'NonPeriodic_xy':                    
                        if iCell == 0:
                            iCell1 = iCell
                            iCell2 = iCell + 1
                            f1 = Solution[iCell1]
                            f2 = Solution[iCell2]
                            InterpolatedSolution[iCell] = 0.5*(3.0*f1 - f2)
                        else:
                            iCell1 = iCell - nCellsX
                            iCell2 = iCell + nCellsX
                            f1 = Solution[iCell1]
                            f2 = Solution[iCell2] 
                            InterpolatedSolution[iCell] = 0.5*(f1 + f2)            
                else:
                    iCell1 = iCell-1
                    iCell2 = iCell                    
                    f1 = Solution[iCell1]
                    f2 = Solution[iCell2]     
                    InterpolatedSolution[iCell] = 0.5*(f1 + f2)  
            else:
                InterpolatedSolution[iCell] = Solution[iCell]                        
        return InterpolatedSolution
    
    def DetermineCellsToBeConsideredForErrorComputation(myMesh,BoundaryCondition):
        nCells = myMesh.nCells
        nCellsX = myMesh.nCellsX
        nCellsToBeConsidered = nCells
        CellsToBeConsidered = np.ones(nCells)
        for iCell in range(0,myMesh.nCells):
            iCellX = np.mod(iCell,nCellsX)
            iCellY = int(float(iCell)/float(nCellsX))
            if BoundaryCondition == 'Periodic' or BoundaryCondition == 'NonPeriodic_x':
                if np.mod(float(iCellY),2.0) == 1.0 and iCellX == nCellsX - 1:
                    CellsToBeConsidered[iCell] = 0.0
                    nCellsToBeConsidered -= 1
            elif BoundaryCondition == 'NonPeriodic_y' or BoundaryCondition == 'NonPeriodic_xy':
                if np.mod(float(iCellY),2.0) == 0.0 and iCellX == nCellsX - 1:
                    CellsToBeConsidered[iCell] = 0.0  
                    nCellsToBeConsidered -= 1         
        return nCellsToBeConsidered, CellsToBeConsidered

    def InterpolateSolutionFromVerticesToCellCenters(myMesh,SolutionAtVertices):
        SolutionAtCellCenters = np.zeros(myMesh.nCells)
        for iCell in range(0,myMesh.nCells):
            CellAreaInverse = 1.0/myMesh.areaCell[iCell]
            for iVertexOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                VertexID = myMesh.verticesOnCell[iCell,iVertexOnCell]
                iVertex = VertexID - 1
                kiteArea = myMesh.kiteAreasOnCell[iCell,iVertexOnCell]
                SolutionAtCellCenters[iCell] += kiteArea*SolutionAtVertices[iVertex]
            SolutionAtCellCenters[iCell] *= CellAreaInverse
        return SolutionAtCellCenters
    
    def InterpolateSolutionFromEdgesToCellCenters(myMesh,SolutionAtEdges):
        SolutionAtCellCenters = np.zeros(myMesh.nCells)
        for iCell in range(0,myMesh.nCells):
            CellAreaInverse = 1.0/myMesh.areaCell[iCell]
            for iEdgeOnCell in range(0,myMesh.nEdgesOnCell[iCell]):
                EdgeID = myMesh.edgesOnCell[iCell,iEdgeOnCell]
                iEdge = EdgeID - 1
                triangleArea = myMesh.triangleAreasOnCell[iCell,iEdgeOnCell]
                SolutionAtCellCenters[iCell] += triangleArea*SolutionAtEdges[iEdge]
            SolutionAtCellCenters[iCell] *= CellAreaInverse
        return SolutionAtCellCenters
    
    def InterpolateSolutionFromCellCentersToEdges(myMesh,SolutionAtCellCenters,SolutionAtEdges,
                                                  InterpolateToBoundaryEdges=False):
        if InterpolateToBoundaryEdges:
            for iEdge in range(0,myMesh.nEdges):
                CellID1 = myMesh.cellsOnEdge[iEdge,0]
                iCell1 = CellID1 - 1
                CellID2 = myMesh.cellsOnEdge[iEdge,1]
                iCell2 = CellID2 - 1
                SolutionAtEdges[iEdge] = 0.5*(SolutionAtCellCenters[iCell1] + SolutionAtCellCenters[iCell2])            
        else:
            for iEdge in range(0,myMesh.nEdges):
                if myMesh.boundaryEdge[iEdge] == 0:
                    CellID1 = myMesh.cellsOnEdge[iEdge,0]
                    iCell1 = CellID1 - 1
                    CellID2 = myMesh.cellsOnEdge[iEdge,1]
                    iCell2 = CellID2 - 1
                    SolutionAtEdges[iEdge] = 0.5*(SolutionAtCellCenters[iCell1] + SolutionAtCellCenters[iCell2])
        return SolutionAtEdges
    
    def InterpolateSolutionFromVerticesToEdges(myMesh,SolutionAtVertices,SolutionAtEdges,
                                               InterpolateToBoundaryEdges=False):
        if InterpolateToBoundaryEdges:
            for iEdge in range(0,myMesh.nEdges):
                VertexID1 = myMesh.verticesOnEdge[iEdge,0]
                iVertex1 = VertexID1 - 1
                VertexID2 = myMesh.verticesOnEdge[iEdge,1]
                iVertex2 = VertexID2 - 1
                SolutionAtEdges[iEdge] = 0.5*(SolutionAtVertices[iVertex1] + SolutionAtVertices[iVertex2])            
        else:
            for iEdge in range(0,myMesh.nEdges):
                if myMesh.boundaryEdge[iEdge] == 0:
                    VertexID1 = myMesh.verticesOnEdge[iEdge,0]
                    iVertex1 = VertexID1 - 1
                    VertexID2 = myMesh.verticesOnEdge[iEdge,1]
                    iVertex2 = VertexID2 - 1
                    SolutionAtEdges[iEdge] = 0.5*(SolutionAtVertices[iVertex1] + SolutionAtVertices[iVertex2])
        return SolutionAtEdges
    
    def InterpolateSolutionFromCellCentersToVertices(myMesh,SolutionAtCellCenters,SolutionAtVertices,
                                                     InterpolateToBoundaryVertices=False):
        if InterpolateToBoundaryVertices:
            for iVertex in range(0,myMesh.nVertices):
                SolutionAtVertices[iVertex] = 0.0
                InverseAreaTriangle = 1.0/myMesh.areaTriangle[iVertex]
                for iVertexDegree in range(0,myMesh.vertexDegree):
                    CellID = myMesh.cellsOnVertex[iVertex,iVertexDegree]
                    iCell = CellID - 1
                    SolutionAtVertices[iVertex] += (
                    SolutionAtCellCenters[iCell]*myMesh.kiteAreasOnVertex[iVertex,iVertexDegree])
                SolutionAtVertices[iVertex] *= InverseAreaTriangle            
        else:
            for iVertex in range(0,myMesh.nVertices):
                if myMesh.boundaryVertex[iVertex] == 0:
                    SolutionAtVertices[iVertex] = 0.0
                    InverseAreaTriangle = 1.0/myMesh.areaTriangle[iVertex]
                    for iVertexDegree in range(0,myMesh.vertexDegree):
                        CellID = myMesh.cellsOnVertex[iVertex,iVertexDegree]
                        iCell = CellID - 1
                        SolutionAtVertices[iVertex] += (
                        SolutionAtCellCenters[iCell]*myMesh.kiteAreasOnVertex[iVertex,iVertexDegree])
                    SolutionAtVertices[iVertex] *= InverseAreaTriangle
        return SolutionAtVertices
    
    def InterpolateSolutionFromEdgesToVertices(myMesh,SolutionAtEdges,SolutionAtVertices,
                                               InterpolateToBoundaryVertices=False):
        if InterpolateToBoundaryVertices:
            for iVertex in range(0,myMesh.nVertices):
                SolutionAtVertices[iVertex] = 0.0
                InverseAreaHexagon = 1.0/myMesh.areaHexagonAtVertex[iVertex]
                for iVertexDegree in range(0,myMesh.vertexDegree):
                    EdgeID = myMesh.edgesOnVertex[iVertex,iVertexDegree]
                    iEdge = EdgeID - 1
                    SolutionAtVertices[iVertex] += (
                    SolutionAtEdges[iEdge]*myMesh.diamondAreaOnEdge[iEdge])
                SolutionAtVertices[iVertex] *= InverseAreaHexagon            
        else:
            for iVertex in range(0,myMesh.nVertices):
                if myMesh.boundaryVertex[iVertex] == 0:
                    SolutionAtVertices[iVertex] = 0.0
                    InverseAreaHexagon = 1.0/myMesh.areaHexagonAtVertex[iVertex]
                    for iVertexDegree in range(0,myMesh.vertexDegree):
                        EdgeID = myMesh.edgesOnVertex[iVertex,iVertexDegree]
                        iEdge = EdgeID - 1
                        SolutionAtVertices[iVertex] += (
                        SolutionAtEdges[iEdge]*myMesh.diamondAreaOnEdge[iEdge])
                    SolutionAtVertices[iVertex] *= InverseAreaHexagon
        return SolutionAtVertices


def PlotMeshes(myCoarseMesh,myFineMesh,OutputDirectory,linewidths,linestyles,colors,labels,labelfontsizes,labelpads,
               tickfontsizes,title,titlefontsize,SaveAsPDF,FileName,Show,fig_size,
               UseDefaultMethodToSpecifyTickFontSize,CellCenterMarkerTypes,CellCenterMarkerSizes):
    cwd = os.getcwd()
    path = cwd + '/' + OutputDirectory + '/'
    if not os.path.exists(path):
        os.mkdir(path) # os.makedir(path)
    os.chdir(path)    
    fig = plt.figure(figsize=(fig_size[0],fig_size[1])) # Create a figure object
    ax = fig.add_subplot(111) # Create an axes object in the figure
    myMeshes = [myCoarseMesh,myFineMesh]
    for iMesh in range(0,2):
        myMesh = myMeshes[iMesh]
        linewidth = linewidths[iMesh]
        linestyle = linestyles[iMesh]
        color = colors[iMesh]
        CellCenterMarkerType = CellCenterMarkerTypes[iMesh]
        CellCenterMarkerSize = CellCenterMarkerSizes[iMesh]
        for iEdge in range(0,myMesh.nEdges):
            dvEdge = myMesh.dvEdge[iEdge]
            vertexID1 = myMesh.verticesOnEdge[iEdge,0]
            vertexID2 = myMesh.verticesOnEdge[iEdge,1]
            iVertex1 = vertexID1 - 1
            iVertex2 = vertexID2 - 1
            x1 = myMesh.xVertex[iVertex1]
            x2 = myMesh.xVertex[iVertex2]
            y1 = myMesh.yVertex[iVertex1]
            y2 = myMesh.yVertex[iVertex2]
            edgeLength = np.sqrt((x2 - x1)**2.0 + (y2 - y1)**2.0)
            dvEdgeTolerancePercentage = 1.0
            if edgeLength <= dvEdge*(100.0 + dvEdgeTolerancePercentage)/100.0:
                plt.plot([x1,x2],[y1,y2],linewidth=linewidth,linestyle=linestyle,color=color)
        for iCell in range(0,myMesh.nCells):
            plt.plot([myMesh.xCell[iCell]],[myMesh.yCell[iCell]],color=color,marker=CellCenterMarkerType,
                     markersize=CellCenterMarkerSize)
    plt.xlabel(labels[0],fontsize=labelfontsizes[0],labelpad=labelpads[0])
    plt.ylabel(labels[1],fontsize=labelfontsizes[1],labelpad=labelpads[1])
    if UseDefaultMethodToSpecifyTickFontSize:
        plt.xticks(fontsize=tickfontsizes[0])
        plt.yticks(fontsize=tickfontsizes[1])
    else:
        ax.tick_params(axis='x',labelsize=tickfontsizes[0])
        ax.tick_params(axis='y',labelsize=tickfontsizes[1])
    plt.gca().get_xaxis().set_major_formatter(FuncFormatter(lambda x, p: format(int(x/1000.0), '')))
    plt.gca().get_yaxis().set_major_formatter(FuncFormatter(lambda y, p: format(int(y/1000.0), '')))
    ax.set_title(title,fontsize=titlefontsize,fontweight='bold',y=1.035)
    if SaveAsPDF:
        plt.savefig(FileName+'.pdf',format='pdf',bbox_inches='tight')
    if Show:
        plt.show()
    plt.close()
    os.chdir(cwd)


def GenerateStructuredRectinilearMeshCoordinateArrays1D(xCellUnstructured,yCellUnstructured,
                                                        PrintMeshCoordinateArrays1D=False):
    nCells = np.size(xCellUnstructured)
    nCellsX = int(np.sqrt(float(nCells)))
    nCellsY = nCellsX
    xCellStructured = np.zeros(nCellsX)
    yCellStructured = np.zeros(nCellsY)
    for iCell in range(0,nCellsX):
        xCellStructured[iCell] = xCellUnstructured[iCell]
    iCellY = 0
    for iCell in range(0,nCells):
        if np.mod(float(iCell),float(nCellsX)) == 0.0:
            yCellStructured[iCellY] = yCellUnstructured[iCell]
            iCellY += 1
    if PrintMeshCoordinateArrays1D:
        print('\nxCellStructured is')
        print(xCellStructured)
        print('\nyCellStructured is')
        print(yCellStructured,'\n')
    return xCellStructured, yCellStructured


def InterpolateSolutionToCoarsestRectilinearMPASOceanMesh(
dx,xCellOnFineRectilinearMesh,yCellOnFineRectilinearMesh,SolutionOnFineRectilinearMesh,xCellOnCoarsestRectilinearMesh,
yCellOnCoarsestRectilinearMesh):
    nCells = np.size(xCellOnFineRectilinearMesh)
    nCellsX = int(np.sqrt(float(nCells)))
    dy = dx*np.sqrt(3.0)/2.0
    x_offset = xCellOnFineRectilinearMesh[0] # x_offset = 0.5*dx
    y_offset = yCellOnFineRectilinearMesh[0]
    nCellsOnCoarsestRectilinearMesh = np.size(xCellOnCoarsestRectilinearMesh)
    SolutionInterpolatedToCoarsestRectilinearMesh = np.zeros(nCellsOnCoarsestRectilinearMesh)
    for iCellOnCoarsestRectilinearMesh in range(0,nCellsOnCoarsestRectilinearMesh):
        x = xCellOnCoarsestRectilinearMesh[iCellOnCoarsestRectilinearMesh]
        y = yCellOnCoarsestRectilinearMesh[iCellOnCoarsestRectilinearMesh]
        iCellX1 = int((x - x_offset)/dx)
        iCellX2 = iCellX1 + 1
        iCellY1 = int((y - y_offset)/dy)
        iCellY2 = iCellY1 + 1
        iCell11 = iCellY1*nCellsX + iCellX1
        x11 = xCellOnFineRectilinearMesh[iCell11]
        y11 = yCellOnFineRectilinearMesh[iCell11]
        f11 = SolutionOnFineRectilinearMesh[iCell11]
        iCell12 = iCellY2*nCellsX + iCellX1
        y12 = yCellOnFineRectilinearMesh[iCell12]
        f12 = SolutionOnFineRectilinearMesh[iCell12]
        iCell21 = iCellY1*nCellsX + iCellX2
        x21 = xCellOnFineRectilinearMesh[iCell21]
        f21 = SolutionOnFineRectilinearMesh[iCell21]        
        iCell22 = iCellY2*nCellsX + iCellX2
        f22 = SolutionOnFineRectilinearMesh[iCell22]         
        xData = np.array([x11,x21])
        yData = np.array([y11,y12])
        fData = np.array([[f11,f12],[f21,f22]])
        SolutionInterpolatedToCoarsestRectilinearMesh[iCellOnCoarsestRectilinearMesh] = (
        CR.BilinearInterpolation(xData,yData,fData,x,y))
    return SolutionInterpolatedToCoarsestRectilinearMesh


def InterpolateSolutionToCoarsestMPASOceanMesh(dx,xCellOnFineRectilinearMesh,yCellOnFineRectilinearMesh,
                                               SolutionOnFineRectilinearMesh,xCellOnCoarsestMesh,yCellOnCoarsestMesh,
                                               CellsOnCoarsestMeshToBeConsidered):
    nCells = np.size(xCellOnFineRectilinearMesh)
    nCellsX = int(np.sqrt(float(nCells)))
    dy = dx*np.sqrt(3.0)/2.0
    x_offset = xCellOnFineRectilinearMesh[0] # x_offset = 0.5*dx
    y_offset = yCellOnFineRectilinearMesh[0]
    nCellsOnCoarsestMesh = np.size(xCellOnCoarsestMesh)
    SolutionInterpolatedToCoarsestMesh = np.zeros(nCellsOnCoarsestMesh)
    for iCellOnCoarsestMesh in range(0,nCellsOnCoarsestMesh):
        if CellsOnCoarsestMeshToBeConsidered[iCellOnCoarsestMesh] == 1.0:
            x = xCellOnCoarsestMesh[iCellOnCoarsestMesh]
            y = yCellOnCoarsestMesh[iCellOnCoarsestMesh]
            iCellX1 = int((x - x_offset)/dx)
            iCellX2 = iCellX1 + 1
            iCellY1 = int((y - y_offset)/dy)
            iCellY2 = iCellY1 + 1
            iCell11 = iCellY1*nCellsX + iCellX1
            x11 = xCellOnFineRectilinearMesh[iCell11]
            y11 = yCellOnFineRectilinearMesh[iCell11]
            f11 = SolutionOnFineRectilinearMesh[iCell11]
            iCell12 = iCellY2*nCellsX + iCellX1
            y12 = yCellOnFineRectilinearMesh[iCell12]
            f12 = SolutionOnFineRectilinearMesh[iCell12]
            iCell21 = iCellY1*nCellsX + iCellX2
            x21 = xCellOnFineRectilinearMesh[iCell21]
            f21 = SolutionOnFineRectilinearMesh[iCell21]        
            iCell22 = iCellY2*nCellsX + iCellX2
            f22 = SolutionOnFineRectilinearMesh[iCell22]         
            xData = np.array([x11,x21])
            yData = np.array([y11,y12])
            fData = np.array([[f11,f12],[f21,f22]])
            SolutionInterpolatedToCoarsestMesh[iCellOnCoarsestMesh] = CR.BilinearInterpolation(xData,yData,fData,x,y)
    return SolutionInterpolatedToCoarsestMesh