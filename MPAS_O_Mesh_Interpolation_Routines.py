
# coding: utf-8

# Name: MPAS_O_Mesh_Interpolation_Routines.ipynb <br/>
# Author: Siddhartha Bishnu <br/>
# Details: This code contains routines for interpolating (a) the state variables from the vertices and the edges to the cell centers of a MPAS-O Mesh, and (b) the state variables from the cell centers of a structured MPAS-O Mesh to the cell centers of a rectilinear mesh generated by shifting the cell centers of every even-numbered row of the original structured MPAS-O Mesh by half a cell width along the negative x-axis, and (c) the state variables from the cell centers of a structured MPAS-O Mesh to the cell centers of a coarser rectilinear mesh occupying the same physical space as the one mentioned in (b) but containing fewer cells in each direction.

# In[1]:

import numpy as np
import io as inputoutput
import sys
from IPython.utils import io
with io.capture_output() as captured:
    import Common_Routines as CR
    import MPAS_O_Mode_Init
    import MPAS_O_Shared


# In[2]:

Plot_MPAS_O_CellCenters_1 = False
if Plot_MPAS_O_CellCenters_1:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/Periodic'
    base_mesh_file_name = 'base_mesh.nc'
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    CR.ScatterPlot(mesh_directory,myMPAS_O.xCell,myMPAS_O.yCell,'k','s',2.5,['Latitude','Longitude'],[17.5,17.5],
                   [10.0,10.0],[15.0,15.0],'MPAS-O Mesh Cell Centers',20.0,True,'MPAS_O_Mesh_CellCenters',False,
                   fig_size=[9.25,9.25],useDefaultMethodToSpecifyTickFontSize=True)


# In[3]:

Plot_MPAS_O_CellCenters_2 = False
if Plot_MPAS_O_CellCenters_2:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/NonPeriodic_x'
    base_mesh_file_name = 'culled_mesh.nc'
    # If you specify the base_mesh_file_name to be base_mesh.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    CR.ScatterPlot(mesh_directory,myMPAS_O.xCell,myMPAS_O.yCell,'k','s',2.5,['Latitude','Longitude'],[17.5,17.5],
                   [10.0,10.0],[15.0,15.0],'MPAS-O Mesh Cell Centers',20.0,True,'MPAS_O_Mesh_CellCenters',False,
                   fig_size=[9.25,9.25],useDefaultMethodToSpecifyTickFontSize=True)


# In[4]:

Plot_MPAS_O_CellCenters_3 = False
if Plot_MPAS_O_CellCenters_3:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'base_mesh_P.nc'
    mesh_file_name = 'mesh_P.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    CR.ScatterPlot(mesh_directory,myMPAS_O.xCell,myMPAS_O.yCell,'k','s',7.5,['Latitude','Longitude'],[17.5,17.5],
                   [10.0,10.0],[15.0,15.0],'MPAS-O Mesh Cell Centers',20.0,True,'MPAS_O_Mesh_CellCenters_P',False,
                   fig_size=[9.25,9.25],useDefaultMethodToSpecifyTickFontSize=True)


# In[5]:

Plot_MPAS_O_CellCenters_4 = False
if Plot_MPAS_O_CellCenters_4:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'culled_mesh_NP.nc'
    # If you specify the base_mesh_file_name to be base_mesh_NP.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh_NP.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    CR.ScatterPlot(mesh_directory,myMPAS_O.xCell,myMPAS_O.yCell,'k','s',7.5,['Latitude','Longitude'],[17.5,17.5],
                   [10.0,10.0],[15.0,15.0],'MPAS-O Mesh Cell Centers',20.0,True,'MPAS_O_Mesh_CellCenters_NP',False,
                   fig_size=[9.25,9.25],useDefaultMethodToSpecifyTickFontSize=True)


# In[6]:

def Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O):
    nCellsX = int(np.sqrt(float(myMPAS_O.nCells)))
    nCellsY = nCellsX
    xCell = np.zeros(myMPAS_O.nCells)
    xCell[:] = myMPAS_O.xCell[:]
    yCell = np.zeros(myMPAS_O.nCells)
    yCell[:] = myMPAS_O.yCell[:]
    # If you want to duplicate an existing array in Python, initialize the duplicate array first and then copy its
    # contents from the existing one, instead of simply assigning the existing array to the duplicate one. The 
    # latter action is equivalent to specifying the duplicate array to be a pointer to the existing array. For 
    # example, if you want to copy the existing array myMPAS_O.xCell to a duplicate array xCell, you should type
    #     xCell = np.zeros(myMPAS_O.nCells)
    #     xCell[:] = myMPAS_O.xCell[:]
    # instead of
    #     xCell = myMPAS_O.xCell
    dx = myMPAS_O.gridSpacingMagnitude
    for iCell in range(0,myMPAS_O.nCells):
        iCellY = int(float(iCell)/float(nCellsX))
        if np.mod(float(iCellY),2.0) == 1.0:
            xCell[iCell] = myMPAS_O.xCell[iCell] - 0.5*dx
    return xCell, yCell


# In[7]:

Generate_Rectilinear_MPAS_O_Mesh_1 = False
if Generate_Rectilinear_MPAS_O_Mesh_1:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/Periodic'
    base_mesh_file_name = 'base_mesh.nc'
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCell, yCell = Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O)
    CR.ScatterPlot(mesh_directory,xCell,yCell,'k','s',2.5,['Latitude','Longitude'],[17.5,17.5],[10.0,10.0],
                   [15.0,15.0],'MPAS-O Mesh Shifted Cell Centers',20.0,True,
                   'MPAS_O_Mesh_Shifted_CellCenters_P',False,fig_size=[9.25,9.25],
                   useDefaultMethodToSpecifyTickFontSize=True)    


# In[8]:

Generate_Rectilinear_MPAS_O_Mesh_2 = False
if Generate_Rectilinear_MPAS_O_Mesh_2:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/NonPeriodic_x'
    base_mesh_file_name = 'culled_mesh.nc'
    # If you specify the base_mesh_file_name to be base_mesh.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)    
    xCell, yCell = Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O)
    CR.ScatterPlot(mesh_directory,xCell,yCell,'k','s',2.5,['Latitude','Longitude'],[17.5,17.5],[10.0,10.0],
                   [15.0,15.0],'MPAS-O Mesh Shifted Cell Centers',20.0,True,
                   'MPAS_O_Mesh_Shifted_CellCenters_P',False,fig_size=[9.25,9.25],
                   useDefaultMethodToSpecifyTickFontSize=True)    


# In[9]:

Generate_Rectilinear_MPAS_O_Mesh_3 = False
if Generate_Rectilinear_MPAS_O_Mesh_3:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'base_mesh_P.nc'
    mesh_file_name = 'mesh_P.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCell, yCell = Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O)
    CR.ScatterPlot(mesh_directory,xCell,yCell,'k','s',7.5,['Latitude','Longitude'],[17.5,17.5],[10.0,10.0],
                   [15.0,15.0],'MPAS-O Mesh Shifted Cell Centers',20.0,True,
                   'MPAS_O_Mesh_Shifted_CellCenters_P',False,fig_size=[9.25,9.25],
                   useDefaultMethodToSpecifyTickFontSize=True)


# In[10]:

Generate_Rectilinear_MPAS_O_Mesh_4 = False
if Generate_Rectilinear_MPAS_O_Mesh_4:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'culled_mesh_NP.nc'
    # If you specify the base_mesh_file_name to be base_mesh_NP.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh_NP.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCell, yCell = Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O)
    CR.ScatterPlot(mesh_directory,xCell,yCell,'k','s',7.5,['Latitude','Longitude'],[17.5,17.5],[10.0,10.0],
                   [15.0,15.0],'MPAS-O Mesh Shifted Cell Centers',20.0,True,
                   'MPAS_O_Mesh_Shifted_CellCenters_NP',False,fig_size=[9.25,9.25],
                   useDefaultMethodToSpecifyTickFontSize=True)


# In[11]:

def Interpolate_Solution_From_MPAS_O_Mesh_To_Rectilinear_MPAS_O_Mesh(myMPAS_O,Solution):
    nCellsX = int(np.sqrt(float(myMPAS_O.nCells)))
    dx = myMPAS_O.gridSpacingMagnitude
    InterpolatedSolution = np.zeros(myMPAS_O.nCells)
    for iCell in range(0,myMPAS_O.nCells):
        iCellY = int(float(iCell)/float(nCellsX))
        if np.mod(float(iCellY),2.0) == 1.0:
            if np.mod(float(iCell),float(nCellsX)) == 0.0:
                if myMPAS_O.myNamelist.config_periodicity == 'Periodic':
                    iCell1 = iCell-1+nCellsX
                    iCell2 = iCell                    
                    f1 = Solution[iCell1]
                    f2 = Solution[iCell2]                         
                    InterpolatedSolution[iCell] = 0.5*(f1 + f2)                    
                else:
                    if myMPAS_O.myNamelist.config_periodicity == 'NonPeriodic_x':
                        iCell1 = iCell - nCellsX
                        iCell2 = int(np.mod(float(iCell+nCellsX),float(myMPAS_O.nCells)))
                        f1 = Solution[iCell1]
                        f2 = Solution[iCell2] 
                        InterpolatedSolution[iCell] = 0.5*(f1 + f2)                     
            else:
                iCell1 = iCell-1
                iCell2 = iCell                    
                f1 = Solution[iCell1]
                f2 = Solution[iCell2]     
                InterpolatedSolution[iCell] = 0.5*(f1 + f2)  
        else:
            InterpolatedSolution[iCell] = Solution[iCell]
    return InterpolatedSolution


# In[12]:

def GenerateStructuredRectinilearMeshCoordinateArrays1D(xCellUnstructured,yCellUnstructured,
                                                        printMeshCoordinateArrays1D=False):
    nCells = np.size(xCellUnstructured)
    nCellsX = int(np.sqrt(float(nCells)))
    nCellsY = nCellsX
    xCellStructured = np.zeros(nCellsX)
    yCellStructured = np.zeros(nCellsY)
    for iCell in range(0,nCellsX):
        xCellStructured[iCell] = xCellUnstructured[iCell]
    iCellY = 0
    for iCell in range(0,nCells):
        if np.mod(float(iCell),float(nCellsX)) == 0.0:
            yCellStructured[iCellY] = yCellUnstructured[iCell]
            iCellY += 1
    if printMeshCoordinateArrays1D:
        print('xCellStructured is')
        print(xCellStructured)
        print(' ')
        print('yCellStructured is')
        print(yCellStructured)
    return xCellStructured, yCellStructured


# In[13]:

test_GenerateStructuredRectinilearMeshCoordinateArrays1D_1 = False
if test_GenerateStructuredRectinilearMeshCoordinateArrays1D_1:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/Periodic'
    base_mesh_file_name = 'base_mesh.nc'
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCellStructured, yCellStructured = (
    GenerateStructuredRectinilearMeshCoordinateArrays1D(myMPAS_O.xCell,myMPAS_O.yCell,
                                                        printMeshCoordinateArrays1D=True))


# In[14]:

test_GenerateStructuredRectinilearMeshCoordinateArrays1D_2 = False
if test_GenerateStructuredRectinilearMeshCoordinateArrays1D_2:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/NonPeriodic_x'
    base_mesh_file_name = 'culled_mesh.nc'
    # If you specify the base_mesh_file_name to be base_mesh.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCellStructured, yCellStructured = (
    GenerateStructuredRectinilearMeshCoordinateArrays1D(myMPAS_O.xCell,myMPAS_O.yCell,
                                                        printMeshCoordinateArrays1D=True))


# In[15]:

test_GenerateStructuredRectinilearMeshCoordinateArrays1D_3 = False
if test_GenerateStructuredRectinilearMeshCoordinateArrays1D_3:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'base_mesh_P.nc'
    mesh_file_name = 'mesh_P.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCellStructured, yCellStructured = (
    GenerateStructuredRectinilearMeshCoordinateArrays1D(myMPAS_O.xCell,myMPAS_O.yCell,
                                                        printMeshCoordinateArrays1D=True))


# In[16]:

test_GenerateStructuredRectinilearMeshCoordinateArrays1D_4 = False
if test_GenerateStructuredRectinilearMeshCoordinateArrays1D_4:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'culled_mesh_NP.nc'
    # If you specify the base_mesh_file_name to be base_mesh_NP.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh_NP.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    xCellStructured, yCellStructured = (
    GenerateStructuredRectinilearMeshCoordinateArrays1D(myMPAS_O.xCell,myMPAS_O.yCell,
                                                        printMeshCoordinateArrays1D=True))


# In[17]:

def Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh(
dx,xCell_FineRectilinearMesh,yCell_FineRectilinearMesh,Solution_FineRectilinearMesh,xCell_CoarsestRectilinearMesh,
yCell_CoarsestRectilinearMesh):
    nCells = np.size(xCell_FineRectilinearMesh)
    nCellsX = int(np.sqrt(float(nCells)))
    nCellsY = nCellsX
    dy = dx*np.sqrt(3.0)/2.0
    x_offset = xCell_FineRectilinearMesh[0] # x_offset = 0.5*dx
    y_offset = yCell_FineRectilinearMesh[0]
    nCells_CoarsestRectilinearMesh = np.size(xCell_CoarsestRectilinearMesh)
    SolutionInterpolatedToCoarsestRectilinearMesh = np.zeros(nCells_CoarsestRectilinearMesh)
    for iCell_CoarsestRectilinearMesh in range(0,nCells_CoarsestRectilinearMesh):
        x = xCell_CoarsestRectilinearMesh[iCell_CoarsestRectilinearMesh]
        y = yCell_CoarsestRectilinearMesh[iCell_CoarsestRectilinearMesh]
        iCellX1 = int((x-x_offset)/dx)
        iCellX2 = iCellX1 + 1
        iCellY1 = int((y-y_offset)/dy)
        iCellY2 = iCellY1 + 1
        iCell11 = iCellY1*nCellsX + iCellX1
        x11 = xCell_FineRectilinearMesh[iCell11]
        y11 = yCell_FineRectilinearMesh[iCell11]
        f11 = Solution_FineRectilinearMesh[iCell11]
        iCell12 = iCellY2*nCellsX + iCellX1
        x12 = xCell_FineRectilinearMesh[iCell12]
        y12 = yCell_FineRectilinearMesh[iCell12]
        f12 = Solution_FineRectilinearMesh[iCell12]
        iCell21 = iCellY1*nCellsX + iCellX2
        x21 = xCell_FineRectilinearMesh[iCell21]
        y21 = yCell_FineRectilinearMesh[iCell21]
        f21 = Solution_FineRectilinearMesh[iCell21]        
        iCell22 = iCellY2*nCellsX + iCellX2
        x22 = xCell_FineRectilinearMesh[iCell22]
        y22 = yCell_FineRectilinearMesh[iCell22]
        f22 = Solution_FineRectilinearMesh[iCell22]         
        xData = np.array([x11,x21])
        yData = np.array([y11,y12])
        fData = np.array([[f11,f12],[f21,f22]])
        SolutionInterpolatedToCoarsestRectilinearMesh[iCell_CoarsestRectilinearMesh] = (
        CR.BilinearInterpolation(xData,yData,fData,x,y))
    return SolutionInterpolatedToCoarsestRectilinearMesh


# In[18]:

def surface_elevation(lX,lY,x,y):
    eta0 = 0.1
    eta = eta0*np.sin(2.0*np.pi*x/lX)*np.sin(2.0*np.pi*y/lY)
    return eta


# In[19]:

def test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh(mesh_directory,periodicity,output_directory,
                                                                  plotFigures=True):
    print_basic_geometry = True
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    nCases = 2
    for iCase in range(0,nCases):
        if periodicity == 'Periodic':
            base_mesh_file_name = 'base_mesh_%s.nc' %(iCase+4)
        elif periodicity == 'NonPeriodic_x':
            base_mesh_file_name = 'culled_mesh_%s.nc' %(iCase+4)
        mesh_file_name = 'mesh_%s.nc' %(iCase+4)
        if iCase == 0:
            myMPAS_O_CoarseMesh = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,
                                                          mesh_file_name,mesh_type,problem_type,problem_is_linear,
                                                          periodicity,do_fixAngleEdge=True,print_Output=False)
        else:
            myMPAS_O_FineMesh = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,
                                                        mesh_file_name,mesh_type,problem_type,problem_is_linear,
                                                        periodicity,do_fixAngleEdge=True,print_Output=False)
    lX = max(myMPAS_O_CoarseMesh.lX,myMPAS_O_FineMesh.lX)
    lY = max(myMPAS_O_CoarseMesh.lY,myMPAS_O_FineMesh.lY)
    for iCell in range(0,myMPAS_O_CoarseMesh.nCells):
        myMPAS_O_CoarseMesh.sshCurrent[iCell] = surface_elevation(lX,lY,myMPAS_O_CoarseMesh.xCell[iCell],
                                                                  myMPAS_O_CoarseMesh.yCell[iCell])
    for iCell in range(0,myMPAS_O_FineMesh.nCells):
        myMPAS_O_FineMesh.sshCurrent[iCell] = surface_elevation(lX,lY,myMPAS_O_FineMesh.xCell[iCell],
                                                                myMPAS_O_FineMesh.yCell[iCell])   
    xCell_CoarseRectilinearMesh, yCell_CoarseRectilinearMesh = (
    Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O_CoarseMesh))        
    InterpolatedSSH_CoarseRectilinearMesh = (
    Interpolate_Solution_From_MPAS_O_Mesh_To_Rectilinear_MPAS_O_Mesh(myMPAS_O_CoarseMesh,
                                                                     myMPAS_O_CoarseMesh.sshCurrent))     
    exactSSH_CoarseRectilinearMesh = np.zeros(myMPAS_O_CoarseMesh.nCells)
    for iCell in range(0,myMPAS_O_CoarseMesh.nCells):
        exactSSH_CoarseRectilinearMesh[iCell] = surface_elevation(lX,lY,xCell_CoarseRectilinearMesh[iCell],
                                                                  yCell_CoarseRectilinearMesh[iCell])
    xCell_FineRectilinearMesh, yCell_FineRectilinearMesh = Generate_Rectilinear_MPAS_O_Mesh(myMPAS_O_FineMesh)
    InterpolatedSSH_FineRectilinearMesh = (
    Interpolate_Solution_From_MPAS_O_Mesh_To_Rectilinear_MPAS_O_Mesh(myMPAS_O_FineMesh,
                                                                     myMPAS_O_FineMesh.sshCurrent)) 
    exactSSH_FineRectilinearMesh = np.zeros(myMPAS_O_FineMesh.nCells)
    for iCell in range(0,myMPAS_O_FineMesh.nCells):
        exactSSH_FineRectilinearMesh[iCell] = surface_elevation(lX,lY,xCell_FineRectilinearMesh[iCell],
                                                                yCell_FineRectilinearMesh[iCell])    
    FineRectilinearMeshSSHInterpolatedToCoarseRectilinearMesh = (
    Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh(
    myMPAS_O_FineMesh.gridSpacingMagnitude,xCell_FineRectilinearMesh,yCell_FineRectilinearMesh,
    InterpolatedSSH_FineRectilinearMesh,xCell_CoarseRectilinearMesh,yCell_CoarseRectilinearMesh))    
    L2InterpolationError_CoarseMeshToCoarseRectilinearMesh = (
    InterpolatedSSH_CoarseRectilinearMesh - exactSSH_CoarseRectilinearMesh)
    L2InterpolationErrorNorm_CoarseMeshToCoarseRectilinearMesh = (
    (np.linalg.norm(L2InterpolationError_CoarseMeshToCoarseRectilinearMesh)
     /np.sqrt(float(myMPAS_O_CoarseMesh.nCells))))
    print('The L2 interpolation error norm from the coarse mesh to the coarse rectilinear mesh is %.15f.' 
          %L2InterpolationErrorNorm_CoarseMeshToCoarseRectilinearMesh)
    L2InterpolationError_FineMeshToFineRectilinearMesh = (
    InterpolatedSSH_FineRectilinearMesh - exactSSH_FineRectilinearMesh)
    L2InterpolationErrorNorm_FineMeshToFineRectilinearMesh = (
    np.linalg.norm(L2InterpolationError_FineMeshToFineRectilinearMesh)/np.sqrt(float(myMPAS_O_FineMesh.nCells)))
    print('The L2 interpolation error norm from the fine mesh to the fine rectilinear mesh is %.15f.' 
          %L2InterpolationErrorNorm_FineMeshToFineRectilinearMesh)    
    L2InterpolationError_FineRectilinearMeshToCoarseRectilinearMesh = (
    FineRectilinearMeshSSHInterpolatedToCoarseRectilinearMesh - exactSSH_CoarseRectilinearMesh)
    L2InterpolationErrorNorm_FineRectilinearMeshToCoarseRectilinearMesh = (
    (np.linalg.norm(L2InterpolationError_FineRectilinearMeshToCoarseRectilinearMesh)
     /np.sqrt(float(myMPAS_O_CoarseMesh.nCells))))
    print(
    'The L2 interpolation error norm from the fine rectilinear mesh to the coarse rectilinear mesh is %.15f.'
    %L2InterpolationErrorNorm_FineRectilinearMeshToCoarseRectilinearMesh)    
    if plotFigures:
        Title = 'SSH on Coarse Mesh'
        FigureTitle = 'SSHOnCoarseMesh_' + periodicity
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O_CoarseMesh.xCell,
                                                          myMPAS_O_CoarseMesh.yCell,
                                                          myMPAS_O_CoarseMesh.sshCurrent,300,False,[0.0,0.0],'x',
                                                          10,'y',10,Title,True,FigureTitle,False)         
        Title = 'Exact SSH on Coarse Rectilinear Mesh'
        FigureTitle = 'ExactSSHOnCoarseRectilinearMesh_' + periodicity
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,xCell_CoarseRectilinearMesh,
                                                          yCell_CoarseRectilinearMesh,
                                                          exactSSH_CoarseRectilinearMesh,
                                                          300,False,[0.0,0.0],'x',10,'y',10,Title,True,
                                                          FigureTitle,False)           
        Title = 'Interpolated SSH on Coarse Rectilinear Mesh'
        FigureTitle = 'InterpolatedSSHOnCoarseRectilinearMesh_' + periodicity
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,xCell_CoarseRectilinearMesh,
                                                          yCell_CoarseRectilinearMesh,
                                                          InterpolatedSSH_CoarseRectilinearMesh,300,False,
                                                          [0.0,0.0],'x',10,'y',10,Title,True,FigureTitle,False) 
        Title = 'SSH on Fine Mesh'
        FigureTitle = 'SSHOnFineMesh'
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O_FineMesh.xCell,
                                                          myMPAS_O_FineMesh.yCell,myMPAS_O_FineMesh.sshCurrent,
                                                          300,False,[0.0,0.0],'x',10,'y',10,Title,True,
                                                          FigureTitle,False)   
        Title = 'Interpolated SSH on Fine Rectilinear Mesh'
        FigureTitle = 'InterpolatedSSHOnFineRectilinearMesh_' + periodicity
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,xCell_FineRectilinearMesh,
                                                          yCell_FineRectilinearMesh,
                                                          InterpolatedSSH_FineRectilinearMesh,300,False,[0.0,0.0],
                                                          'x',10,'y',10,Title,True,FigureTitle,False) 
        Title = 'Fine Rectilinear Mesh SSH\nInterpolated to Coarse Rectilinear Mesh'
        FigureTitle = 'FineRectilinearMeshSSHInterpolatedToCoarseRectilinearMesh_' + periodicity
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(
        output_directory,xCell_CoarseRectilinearMesh,yCell_CoarseRectilinearMesh,
        FineRectilinearMeshSSHInterpolatedToCoarseRectilinearMesh,300,False,[0.0,0.0],'x',10,'y',10,Title,True,
        FigureTitle,False) 


# In[20]:

test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh_1 = False
if test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh_1:
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/ConvergenceStudyMeshes/Periodic'
    periodicity = 'Periodic'
    output_directory = mesh_directory
    test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh(mesh_directory,periodicity,output_directory)


# In[21]:

test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh_2 = False
if test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh_2:
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/ConvergenceStudyMeshes/NonPeriodic_x'
    periodicity = 'NonPeriodic_x'
    output_directory = mesh_directory
    test_Interpolate_Solution_To_Coarsest_Rectilinear_MPAS_O_Mesh(mesh_directory,periodicity,output_directory)


# In[22]:

def Interpolate_Solution_From_Vertices_To_Cell_Centers(myMPAS_O,SolutionAtVertices):
    MPAS_O_Shared.ocn_init_routines_setup_sign_and_index_fields(myMPAS_O)
    SolutionAtCellCenters = np.zeros(myMPAS_O.nCells)
    for iCell in range(0,myMPAS_O.nCells):
        CellAreaInverse = 1.0/myMPAS_O.areaCell[iCell]
        for iVertexOnCell in range(0,myMPAS_O.nEdgesOnCell[iCell]):
            jID = myMPAS_O.kiteIndexOnCell[iCell,iVertexOnCell]
            j = jID - 1
            iVertexID = myMPAS_O.verticesOnCell[iCell,iVertexOnCell]
            iVertex = iVertexID - 1
            if myMPAS_O.myNamelist.config_mesh_type == 'uniform':
                SolutionAtCellCenters[iCell] += SolutionAtVertices[iVertex]/6.0
            else:                
                SolutionAtCellCenters[iCell] += (
                myMPAS_O.kiteAreasOnVertex[iVertex,j]*SolutionAtVertices[iVertex]*CellAreaInverse)
    return SolutionAtCellCenters


# In[23]:

def Interpolate_Solution_From_Edges_To_Cell_Centers(myMPAS_O,SolutionAtEdges):
    MPAS_O_Shared.ocn_init_routines_setup_sign_and_index_fields(myMPAS_O)
    SolutionAtCellCenters = np.zeros(myMPAS_O.nCells)
    for iCell in range(0,myMPAS_O.nCells):
        for iEdgeOnCell in range(0,myMPAS_O.nEdgesOnCell[iCell]):
            iEdgeID = myMPAS_O.edgesOnCell[iCell,iEdgeOnCell]
            iEdge = iEdgeID - 1
            if myMPAS_O.myNamelist.config_mesh_type == 'uniform':
                SolutionAtCellCenters[iCell] += SolutionAtEdges[iEdge]/6.0
    return SolutionAtCellCenters


# In[24]:

def test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers(myMPAS_O,output_directory,plotFigures=True,
                                                                      FigureTitleSuffix=''):
    ExactSSHAtVertices = np.zeros(myMPAS_O.nVertices)
    ExactSSHAtEdges = np.zeros(myMPAS_O.nEdges)
    ExactSSHAtCellCenters = np.zeros(myMPAS_O.nCells)
    InterpolatedSSHFromVerticesToCellCenters = np.zeros(myMPAS_O.nCells)
    SSHInterpolationErrorFromVerticesToCellCenters = np.zeros(myMPAS_O.nCells)
    InterpolatedSSHFromEdgesToCellCenters = np.zeros(myMPAS_O.nCells)
    SSHInterpolationErrorFromEdgesToCellCenters = np.zeros(myMPAS_O.nCells)
    for iVertex in range(0,myMPAS_O.nVertices):
        ExactSSHAtVertices[iVertex] = surface_elevation(myMPAS_O.lX,myMPAS_O.lY,myMPAS_O.xVertex[iVertex],
                                                        myMPAS_O.yVertex[iVertex])
    for iEdge in range(0,myMPAS_O.nEdges):
        ExactSSHAtEdges[iEdge] = surface_elevation(myMPAS_O.lX,myMPAS_O.lY,myMPAS_O.xEdge[iEdge],
                                                   myMPAS_O.yEdge[iEdge])        
    for iCell in range(0,myMPAS_O.nCells):
        ExactSSHAtCellCenters[iCell] = surface_elevation(myMPAS_O.lX,myMPAS_O.lY,myMPAS_O.xCell[iCell],
                                                         myMPAS_O.yCell[iCell])          
    InterpolatedSSHFromVerticesToCellCenters = (
    Interpolate_Solution_From_Vertices_To_Cell_Centers(myMPAS_O,ExactSSHAtVertices))
    SSHInterpolationErrorFromVerticesToCellCenters = (
    InterpolatedSSHFromVerticesToCellCenters - ExactSSHAtCellCenters)
    InterpolatedSSHFromEdgesToCellCenters = (
    Interpolate_Solution_From_Edges_To_Cell_Centers(myMPAS_O,ExactSSHAtEdges))  
    SSHInterpolationErrorFromEdgesToCellCenters = (
    InterpolatedSSHFromEdgesToCellCenters - ExactSSHAtCellCenters)
    if plotFigures:
        Title = 'Exact SSH At Vertices'
        FigureTitle = 'ExactSSHAtVertices' + FigureTitleSuffix
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xVertex,myMPAS_O.yVertex,
                                                          ExactSSHAtVertices,300,False,[0.0,0.0],'x',10,'y',10,
                                                          Title,True,FigureTitle,False)
        Title = 'Exact SSH At Edges'
        FigureTitle = 'ExactSSHAtEdges' + FigureTitleSuffix
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xEdge,myMPAS_O.yEdge,
                                                          ExactSSHAtEdges,300,False,[0.0,0.0],'x',10,'y',10,Title,
                                                          True,FigureTitle,False) 
        Title = 'Exact SSH At Cell Centers'
        FigureTitle = 'ExactSSHAtCellCenters' + FigureTitleSuffix 
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xCell,myMPAS_O.yCell,
                                                          ExactSSHAtCellCenters,300,False,[0.0,0.0],'x',10,'y',10,
                                                          Title,True,FigureTitle,False) 
        Title = 'Interpolated SSH from Vertices to Cell Centers'
        FigureTitle = 'InterpolatedSSHFromVerticesToCellCenters' + FigureTitleSuffix 
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xCell,myMPAS_O.yCell,
                                                          InterpolatedSSHFromVerticesToCellCenters,300,False,
                                                          [0.0,0.0],'x',10,'y',10,Title,True,FigureTitle,False)   
        Title = 'SSH Interpolation Error from Vertices to Cell Centers'
        FigureTitle = 'SSHInterpolationErrorFromVerticesToCellCenters' + FigureTitleSuffix 
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xCell,myMPAS_O.yCell,
                                                          SSHInterpolationErrorFromVerticesToCellCenters,300,False,
                                                          [0.0,0.0],'x',10,'y',10,Title,True,FigureTitle,False)
        Title = 'Interpolated SSH from Edges to Cell Centers'
        FigureTitle = 'InterpolatedSSHFromEdgesToCellCenters' + FigureTitleSuffix 
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xCell,myMPAS_O.yCell,
                                                          InterpolatedSSHFromEdgesToCellCenters,300,False,
                                                          [0.0,0.0],'x',10,'y',10,Title,True,FigureTitle,False)
        Title = 'SSH Interpolation Error from Edges to Cell Centers'
        FigureTitle = 'SSHInterpolationErrorFromEdgesToCellCenters' + FigureTitleSuffix 
        CR.PythonFilledUnstructuredContourPlot2DSaveAsPNG(output_directory,myMPAS_O.xCell,myMPAS_O.yCell,
                                                          SSHInterpolationErrorFromEdgesToCellCenters,300,False,
                                                          [0.0,0.0],'x',10,'y',10,Title,True,FigureTitle,False)


# In[25]:

test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_1 = False
if test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_1:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/Periodic'
    base_mesh_file_name = 'base_mesh.nc'
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    output_directory = mesh_directory
    test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers(myMPAS_O,output_directory)


# In[26]:

test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_2 = False
if test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_2:
    print_basic_geometry = True
    mesh_directory = 'Mesh+Initial_Condition+Registry_Files/NonPeriodic_x'
    base_mesh_file_name = 'culled_mesh.nc'
    # If you specify the base_mesh_file_name to be base_mesh.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    output_directory = mesh_directory
    test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers(myMPAS_O,output_directory)


# In[27]:

test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_3 = False
if test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_3:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'base_mesh_P.nc'
    mesh_file_name = 'mesh_P.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'Periodic'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    output_directory = mesh_directory
    test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers(myMPAS_O,output_directory,
                                                                      FigureTitleSuffix='_P')


# In[28]:

test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_4 = False
if test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers_4:
    print_basic_geometry = True
    mesh_directory = 'MPAS_O_Shallow_Water_Mesh_Generation/CoastalKelvinWaveMesh/PlotMesh'
    base_mesh_file_name = 'culled_mesh_NP.nc'
    # If you specify the base_mesh_file_name to be base_mesh_NP.nc and my_mesh_file_name to be base_mesh_file_name,
    # the fixAngle routine will not work unless you also specify determineYCellAlongLatitude to be False.
    mesh_file_name = 'mesh_NP.nc'
    mesh_type = 'uniform'
    problem_type = 'default'
    problem_is_linear = True
    periodicity = 'NonPeriodic_x'
    myMPAS_O = MPAS_O_Mode_Init.MPAS_O(print_basic_geometry,mesh_directory,base_mesh_file_name,mesh_file_name,
                                       mesh_type,problem_type,problem_is_linear,periodicity,do_fixAngleEdge=True,
                                       print_Output=False)
    output_directory = mesh_directory
    test_Interpolate_Solution_From_Vertices_And_Edges_To_Cell_Centers(myMPAS_O,output_directory,
                                                                      FigureTitleSuffix='_NP')